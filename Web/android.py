import copy
import pandas as pd
import torch
import pickle
import json
from graphsage_model import GraphSageModel
from function import create_app_api_vector, extract_api


class Android:
    def __init__(self):
        self.dataset_m1 = torch.load(f'static/full_dataset_{400}_m1.pt')
        self.dataset_m2 = torch.load(f'static/full_dataset_{400}_m2.pt')
        self.dataset_m3 = torch.load(f'static/full_dataset_{400}_m3.pt')
        self.dataset_m4 = torch.load(f'static/full_dataset_{400}_m4.pt')
        self.encoder = pickle.load(open(f'static/encoder_{400}.pkl', 'rb'))
        self.diminutive_m1 = torch.load(f'static/diminutive_m1.pt')
        self.diminutive_m2 = torch.load(f'static/diminutive_m2.pt')
        self.diminutive_m3 = torch.load(f'static/diminutive_m3.pt')
        self.diminutive_m4 = torch.load(f'static/diminutive_m4.pt')
        self.method = pd.read_csv(f'static/method_400_APIs.csv', header=0, index_col='Unnamed: 0').to_numpy()
        self.package = pd.read_csv(f'static/package_400_APIs.csv', header=0, index_col='Unnamed: 0').to_numpy()
        self.invoke = pd.read_csv(f'static/invoke_400_APIs.csv', header=0, index_col='Unnamed: 0').to_numpy()

        self.api_names = json.load(open('static/APIs_in_All_RFE.json', "r"))[:400]

        device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
        self.model = GraphSageModel().to(device)
        self.model.load_state_dict(torch.load(f'static/model_{400}.pth', map_location=device))

    def get_api_vector(self, decompile_path):
        return create_app_api_vector(extract_api(self.api_names, decompile_path))

    def predict(self, decompile_path):
        def add_node(dataset_, new_node, diminutive, temp=None):
            dataset = copy.deepcopy(dataset_)
            number_of_new_nodes = new_node.shape[0]
            edge_weight = torch.tensor(new_node @ diminutive)
            if temp is None:
                self_connection = torch.tensor(new_node @ new_node.T)
            else:
                self_connection = torch.tensor(new_node @ temp @ new_node.T)
            edge_weight = torch.cat([edge_weight, torch.diagonal(self_connection).reshape(-1, 1)], dim=1)
            max_elements, max_idxs = torch.max(edge_weight, 1)

            edge_weight = torch.div(edge_weight, max_elements.reshape(-1, 1) + 0.001)
            edge_weight = edge_weight.flatten()

            new_node_index_start = dataset.edge_index.max().item() + 1

            index_0 = []
            index_1 = []
            for i in range(number_of_new_nodes):
                index_0.extend([new_node_index_start + i] * (new_node_index_start + 1))
                index_1.extend(list(range(0, new_node_index_start)) + [new_node_index_start + i])
            edge_index = torch.tensor([index_0, index_1])

            dataset.x = torch.cat([dataset.x, torch.from_numpy(new_node).float()], dim=0)
            dataset.edge_index = torch.cat([dataset.edge_index, edge_index], dim=1)
            dataset.edge_weight = torch.cat([dataset.edge_weight, edge_weight], dim=-1)
            dataset.y = torch.cat([dataset.y, torch.tensor([0])], dim=-1)
            dataset.test_mask = torch.asarray([False] * new_node_index_start + [True] * number_of_new_nodes)
            return dataset

        new_vector = self.get_api_vector(decompile_path)
        new_graph_m1 = add_node(self.dataset_m1, new_vector, self.diminutive_m1, None)
        new_graph_m2 = add_node(self.dataset_m2, new_vector, self.diminutive_m2, self.method)
        new_graph_m3 = add_node(self.dataset_m3, new_vector, self.diminutive_m3, self.package)
        new_graph_m4 = add_node(self.dataset_m4, new_vector, self.diminutive_m4, self.invoke)

        pred = self.model(new_graph_m1, new_graph_m2, new_graph_m3, new_graph_m4).argmax(dim=1)
        return self.encoder.inverse_transform([pred[-1].to('cpu').item()])[0]
