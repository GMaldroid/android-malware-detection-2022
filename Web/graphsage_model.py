import torch
import torch.nn as nn
import torch.nn.functional as F
from torch_geometric.nn import GraphConv


layer_nodes = [64, 32, 16]
dropout = 0.3


class GraphSageModel(torch.nn.Module):
    def __init__(self):
        super().__init__()
        self.conv1_m1 = GraphConv(-1, layer_nodes[0], aggr='mean', normalize=True)
        self.conv2_m1 = GraphConv(-1, layer_nodes[1], aggr='mean', normalize=True)
        self.dense_m1 = nn.Linear(layer_nodes[1], layer_nodes[2])

        self.conv1_m2 = GraphConv(-1, layer_nodes[0], aggr='mean', normalize=True)
        self.conv2_m2 = GraphConv(-1, layer_nodes[1], aggr='mean', normalize=True)
        self.dense_m2 = nn.Linear(layer_nodes[1], layer_nodes[2])

        self.conv1_m3 = GraphConv(-1, layer_nodes[0], aggr='mean', normalize=True)
        self.conv2_m3 = GraphConv(-1, layer_nodes[1], aggr='mean', normalize=True)
        self.dense_m3 = nn.Linear(layer_nodes[1], layer_nodes[2])

        self.conv1_m4 = GraphConv(-1, layer_nodes[0], aggr='mean', normalize=True)
        self.conv2_m4 = GraphConv(-1, layer_nodes[1], aggr='mean', normalize=True)
        self.dense_m4 = nn.Linear(layer_nodes[1], layer_nodes[2])

        self.dense = nn.Linear(layer_nodes[2] * 4, 5)

    def forward(self, data_m1, data_m2, data_m3, data_m4):
        x_m1 = self.conv1_m1(data_m1.x, data_m1.edge_index, data_m1.edge_weight)
        x_m1 = F.relu(x_m1)
        x_m1 = F.dropout(x_m1, p=dropout, training=self.training)
        x_m1 = self.conv2_m1(x_m1, data_m1.edge_index, data_m1.edge_weight)
        x_m1 = F.relu(x_m1)
        x_m1 = F.dropout(x_m1, p=dropout, training=self.training)
        x_m1 = self.dense_m1(x_m1)

        x_m2 = self.conv1_m2(data_m2.x, data_m2.edge_index, data_m2.edge_weight)
        x_m2 = F.relu(x_m2)
        x_m2 = F.dropout(x_m2, p=dropout, training=self.training)
        x_m2 = self.conv2_m2(x_m2, data_m2.edge_index, data_m2.edge_weight)
        x_m2 = F.relu(x_m2)
        x_m2 = F.dropout(x_m2, p=dropout, training=self.training)
        x_m2 = self.dense_m2(x_m2)

        x_m3 = self.conv1_m3(data_m3.x, data_m3.edge_index, data_m3.edge_weight)
        x_m3 = F.relu(x_m3)
        x_m3 = F.dropout(x_m3, p=dropout, training=self.training)
        x_m3 = self.conv2_m3(x_m3, data_m3.edge_index, data_m3.edge_weight)
        x_m3 = F.relu(x_m3)
        x_m3 = F.dropout(x_m3, p=dropout, training=self.training)
        x_m3 = self.dense_m3(x_m3)

        x_m4 = self.conv1_m4(data_m4.x, data_m4.edge_index, data_m4.edge_weight)
        x_m4 = F.relu(x_m4)
        x_m4 = F.dropout(x_m4, p=dropout, training=self.training)
        x_m4 = self.conv2_m4(x_m4, data_m4.edge_index, data_m4.edge_weight)
        x_m4 = F.relu(x_m4)
        x_m4 = F.dropout(x_m4, p=dropout, training=self.training)
        x_m4 = self.dense_m4(x_m4)

        x = torch.cat((x_m1, x_m2, x_m3, x_m4), dim=1)
        x = self.dense(x)
        return F.log_softmax(x, dim=1)
