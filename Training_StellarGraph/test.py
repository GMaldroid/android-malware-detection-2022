import pickle
import pandas as pd
import numpy as np
from tensorflow.keras import layers, optimizers, losses, Model # type: ignore
import stellargraph as sg
from stellargraph.layer import GraphSAGE
from stellargraph import StellarGraph
from stellargraph.mapper import GraphSAGENodeGenerator


num_top = 400

## initial parameters
batch_size = 100
num_samples = [10]
layer_sizes = [32]
epochs = 100
dropout = 0.4
lr = 0.005

## load existed graph full and sampled
graph_full = pickle.load(open(f'output/graph_full_{num_top}.pickle', 'rb'))
graph_full_nx = graph_full.to_networkx()
graph_sampled = pickle.load(open(f'output/graph_sampled_{num_top}.pickle', 'rb'))

## load pre-trained weights
generator = GraphSAGENodeGenerator(graph_sampled, batch_size, num_samples, weighted=True)
graphsage_model = GraphSAGE(
    layer_sizes=layer_sizes, generator=generator, bias=True, dropout=dropout,
)
x_inp, x_out = graphsage_model.in_out_tensors()
prediction = layers.Dense(units=5, activation="softmax")(x_out)

model = Model(inputs=x_inp, outputs=prediction)
model.compile(
    optimizer=optimizers.Adam(learning_rate=lr),
    loss=losses.categorical_crossentropy,
    metrics=["acc"],
)
model.load_weights(f'output/model_{num_top}.h5')

## Append new nodes to graph_full
X_train = pd.read_csv(f'../JsonFilesToMatrix/output/top_{num_top}_APIs/app_api_{num_top}_APIs_train.csv', header=0, index_col='Unnamed: 0')
y_train = X_train.pop('Label')
x_train = X_train.to_numpy()

X_test = pd.read_csv(f'../JsonFilesToMatrix/output/top_{num_top}_APIs/app_api_{num_top}_APIs_test.csv', header=0, index_col='Unnamed: 0')
y_test = X_test.pop('Label')
x_test = X_test.to_numpy()

with open(f'./output/encoder_{num_top}.pkl', 'rb') as fp:
    encoder = pickle.load(fp)
test_targets = encoder.transform(y_test)

# create new edge_data -> OK
edge_data = x_test @ x_train.T
self_connections = x_test @ x_test.T
edge_data = np.hstack((edge_data, np.diagonal(self_connections).reshape(-1, 1)))
edge_data = edge_data / (np.amax(edge_data, axis=1).reshape(-1, 1) + 0.001)

number_of_new_nodes = X_test.shape[0]
exist_node_indexes = list(graph_full_nx.nodes())
new_node_index_start = max_node_index = max(exist_node_indexes) + 1

# create new edges -> OK
edge_list = [(new_node_index_start + new_node_index, exist_node_index, edge_data[new_node_index, exist_node_index]) \
             for new_node_index in range(number_of_new_nodes) for exist_node_index in exist_node_indexes]

# create new nodes -> OK
# node_features = {}
# for i in range(number_of_new_nodes):
#     node_features[new_node_index_start + i] = {
#         'label': 'default',
#         'feature': x_test[i, :]
#     }

# graph_full_nx.add_nodes_from(node_features.items())
graph_full_nx.add_edges_from(edge_list)

X = X_train.append(X_test) # type: ignore
X = X.reset_index(drop=True)
graph_test = sg.StellarGraph.from_networkx(graph_full_nx, node_features=X)
generator_test = GraphSAGENodeGenerator(graph_test, batch_size, num_samples)
# hold_out_gen = generator_test.flow(pd.Int64Index(range(new_node_index_start, new_node_index_start + number_of_new_nodes)), test_targets) # type: ignore
hold_out_gen = generator_test.flow(pd.Series(range(new_node_index_start, new_node_index_start + number_of_new_nodes)), test_targets) # type: ignore
hold_out_predictions = model.predict(hold_out_gen)
hold_out_metrics = model.evaluate(hold_out_gen)

print("\nHold Out Set Metrics:")
for name, val in zip(model.metrics_names, hold_out_metrics):
    print("\t{}: {:0.4f}".format(name, val))
