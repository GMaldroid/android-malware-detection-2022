import pickle
import pandas as pd
import torch
from torch_geometric.loader import NeighborLoader

from library import add_new_nodes
from model import GraphSageModel

num_top = 400
epochs = 50
lr = 0.001
batch_size = 128
num_neighbors = [10, 10]

dataset_m1 = torch.load(f'./output/full_dataset_{num_top}_m1.pt')
dataset_m2 = torch.load(f'./output/full_dataset_{num_top}_m2.pt')
dataset_m3 = torch.load(f'./output/full_dataset_{num_top}_m3.pt')
dataset_m4 = torch.load(f'./output/full_dataset_{num_top}_m4.pt')
encoder = pickle.load(open(f'./output/encoder_{num_top}.pkl', 'rb'))
method = pd.read_csv(f'../JsonFilesToMatrix/output/top_400_APIs/method_{num_top}_APIs.csv', header=0,
                     index_col='Unnamed: 0').to_numpy()
package = pd.read_csv(f'../JsonFilesToMatrix/output/top_400_APIs/package_{num_top}_APIs.csv', header=0,
                      index_col='Unnamed: 0').to_numpy()
invoke = pd.read_csv(f'../JsonFilesToMatrix/output/top_400_APIs/invoke_{num_top}_APIs.csv', header=0,
                     index_col='Unnamed: 0').to_numpy()

model = GraphSageModel()
model.load_state_dict(torch.load(f"./output/model_{num_top}.pth", map_location=torch.device('cpu')))

X_train = pd.read_csv(f'../JsonFilesToMatrix/output/top_400_APIs/app_api_{num_top}_APIs_train.csv', header=0,
                      index_col='Unnamed: 0')
y_train = X_train.pop('Label')
x_train = X_train.to_numpy()

X_test = pd.read_csv(f'../JsonFilesToMatrix/output/top_400_APIs/app_api_{num_top}_APIs_test.csv', header=0,
                     index_col='Unnamed: 0')

pred_dict = {
    'Adware': {'Adware': 0, 'Banking': 0, 'Benign': 0, 'Riskware': 0, 'SMS': 0},
    'Banking': {'Adware': 0, 'Banking': 0, 'Benign': 0, 'Riskware': 0, 'SMS': 0},
    'Benign': {'Adware': 0, 'Banking': 0, 'Benign': 0, 'Riskware': 0, 'SMS': 0},
    'Riskware': {'Adware': 0, 'Banking': 0, 'Benign': 0, 'Riskware': 0, 'SMS': 0},
    'SMS': {'Adware': 0, 'Banking': 0, 'Benign': 0, 'Riskware': 0, 'SMS': 0},
}

# for i in range(X_test[500:1000].shape[0]):
for i in range(5):
    x_test = X_test[i: i + 1]
    y_test = x_test.pop('Label')
    x_test = x_test.to_numpy()
    y_test_label_encode = torch.from_numpy(encoder.transform(y_test))

    test_dataset_m1 = add_new_nodes(dataset_m1, x_test, y_test_label_encode, x_train, None)
    test_dataset_m2 = add_new_nodes(dataset_m2, x_test, y_test_label_encode, x_train, method)
    test_dataset_m3 = add_new_nodes(dataset_m3, x_test, y_test_label_encode, x_train, package)
    test_dataset_m4 = add_new_nodes(dataset_m4, x_test, y_test_label_encode, x_train, invoke)

    pred = model(test_dataset_m1, test_dataset_m2, test_dataset_m3, test_dataset_m4).argmax(dim=1)

    pred_value = encoder.inverse_transform([pred[-1].to('cpu').item()])[0]
    real_value = y_test.values[0]

    print(f'{i}: real_value: {real_value}, pred_value: {pred_value}')
    pred_dict[real_value][pred_value] += 1

print(pred_dict)
