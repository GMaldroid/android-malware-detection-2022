import pickle
import pandas as pd
import torch
from torch_geometric.loader import NeighborLoader

from library import add_new_nodes
from model import GraphSageModel


num_top = 400
epochs = 50
lr = 0.001
batch_size = 50
num_neighbors = [10, 20]


dataset_m1 = torch.load(f'./output/full_dataset_{num_top}_m1.pt')
dataset_m2 = torch.load(f'./output/full_dataset_{num_top}_m2.pt')
dataset_m3 = torch.load(f'./output/full_dataset_{num_top}_m3.pt')
dataset_m4 = torch.load(f'./output/full_dataset_{num_top}_m4.pt')
encoder = pickle.load(open(f'./output/encoder_{num_top}.pkl', 'rb'))

X_train = pd.read_csv(f'/content/drive/MyDrive/PyG/top_{num_top}_APIs/app_api_{num_top}_APIs_train.csv', header=0, index_col='Unnamed: 0')
y_train = X_train.pop('Label')
x_train = X_train.to_numpy()

X_test = pd.read_csv(f'/content/drive/MyDrive/PyG/top_{num_top}_APIs/app_api_{num_top}_APIs_test.csv', header=0, index_col='Unnamed: 0')
y_test = X_test.pop('Label')
x_test = X_test.to_numpy()
y_test_label_encode = torch.from_numpy(encoder.transform(y_test))

new_node_index_start_m1, test_dataset_m1 = add_new_nodes(dataset_m1, x_test, y_test_label_encode, x_train)
new_node_index_start_m2, test_dataset_m2 = add_new_nodes(dataset_m2, x_test, y_test_label_encode, x_train)
new_node_index_start_m3, test_dataset_m3 = add_new_nodes(dataset_m3, x_test, y_test_label_encode, x_train)
new_node_index_start_m4, test_dataset_m4 = add_new_nodes(dataset_m4, x_test, y_test_label_encode, x_train)

test_dataset_m1.test_mask = torch.asarray([False] * new_node_index_start_m1 + [True] * 4000)
test_dataset_m2.test_mask = torch.asarray([False] * new_node_index_start_m2 + [True] * 4000)
test_dataset_m3.test_mask = torch.asarray([False] * new_node_index_start_m3 + [True] * 4000)
test_dataset_m4.test_mask = torch.asarray([False] * new_node_index_start_m4 + [True] * 4000)


torch.manual_seed(42)
test_new_node_loader_m1 = [data for data in NeighborLoader(data=test_dataset_m1, input_nodes=None, num_neighbors=num_neighbors, batch_size=batch_size, directed=True, shuffle=False, num_workers=1)]

torch.manual_seed(42)
test_new_node_loader_m2 = [data for data in NeighborLoader(data=test_dataset_m2, input_nodes=None, num_neighbors=num_neighbors, batch_size=batch_size, directed=True, shuffle=False, num_workers=1)]

torch.manual_seed(42)
test_new_node_loader_m3 = [data for data in NeighborLoader(data=test_dataset_m3, input_nodes=None, num_neighbors=num_neighbors, batch_size=batch_size, directed=True, shuffle=False, num_workers=1)]

torch.manual_seed(42)
test_new_node_loader_m4 = [data for data in NeighborLoader(data=test_dataset_m4, input_nodes=None, num_neighbors=num_neighbors, batch_size=batch_size, directed=True, shuffle=False, num_workers=1)]


device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
model = GraphSageModel().to(device)
model.load_state_dict(torch.load(f"./output/model_{num_top}.pth"))

test_newgraph_acc = 0
test_newgraph_node_total = 0
model.eval()

for i in range(len(test_new_node_loader_m1)):
    test_batch_node = test_new_node_loader_m1[i].x.shape[0]
    test_newgraph_node_total += test_batch_node

    data_m1 = test_new_node_loader_m1[i].to(device)
    data_m2 = test_new_node_loader_m2[i].to(device)
    data_m3 = test_new_node_loader_m3[i].to(device)
    data_m4 = test_new_node_loader_m4[i].to(device)

    pred = model(data_m1, data_m2, data_m3, data_m4).argmax(dim=1)
    correct = (pred[data_m1.test_mask] == data_m1.y[data_m1.test_mask]).sum()
    acc = int(correct) / int(data_m1.test_mask.sum())
    test_newgraph_acc += acc * test_batch_node

print(f'Accuracy of test newgraph: {test_newgraph_acc/test_newgraph_node_total:.4f}')
